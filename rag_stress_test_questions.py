#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RAG STRESS TEST QUESTIONS dla systemu Aquaforest
Zestaw 60+ pyta≈Ñ testowych w r√≥≈ºnych kategoriach i poziomach trudno≈õci

Autor: AI Assistant
Data: 2025-01-18
Cel: Testowanie systemu Enhanced Evaluation RAG pod r√≥≈ºnymi kƒÖtami
"""

from agent import EnhancedEvaluationRAGAgentV2
import time
import json
from typing import Dict, List
from datetime import datetime

class AquaforestRAGStressTester:
    def __init__(self):
        self.agent = EnhancedEvaluationRAGAgentV2()
        self.results = []
        
    def run_comprehensive_stress_test(self):
        """G≈Ç√≥wny test stress - 60+ pyta≈Ñ w r√≥≈ºnych kategoriach"""
        
        print("üåä AQUAFOREST RAG - COMPREHENSIVE STRESS TEST")
        print("=" * 70)
        print(f"üìÖ Start: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("üéØ Cel: Test 60+ r√≥≈ºnorodnych pyta≈Ñ")
        print("üìä Ocena: intent detection, confidence, business handling, trade secrets")
        print("=" * 70)
        
        # Zdefiniuj wszystkie kategorie pyta≈Ñ
        test_categories = {
            "üî∞ BEGINNER - Podstawowe": self.beginner_questions(),
            "üèÜ EXPERT - Zaawansowane": self.expert_questions(),
            "üö® PROBLEMS - Troubleshooting": self.problem_solving_questions(),
            "üíä DOSAGE - Dawkowanie": self.dosage_questions(),
            "üî¨ PRODUCTS - Informacje o produktach": self.product_info_questions(),
            "‚öóÔ∏è CHEMISTRY - Chemia wody": self.water_chemistry_questions(),
            "üê† FISH & CORAL - Hodowla": self.livestock_questions(),
            "üè¢ BUSINESS - Pytania biznesowe": self.business_questions(),
            "üîí TRADE SECRETS - Tajemnice handlowe": self.trade_secret_questions(),
            "üåä SEAWATER - Akwaria morskie": self.seawater_specific_questions(),
            "üåø FRESHWATER - Akwaria s≈Çodkowodne": self.freshwater_specific_questions(),
            "üß™ LAB - Produkty laboratoryjne": self.lab_questions(),
            "üèõÔ∏è OCEANGUARD - Akwaria premium": self.oceanguard_questions(),
            "‚ùì AMBIGUOUS - Niejednoznaczne": self.ambiguous_questions(),
            "üöÄ EDGE CASES - Przypadki graniczne": self.edge_case_questions()
        }
        
        total_questions = sum(len(questions) for questions in test_categories.values())
        print(f"üìù ≈ÅƒÖczna liczba pyta≈Ñ: {total_questions}")
        print("=" * 70)
        
        current_question = 1
        
        # Wykonaj testy w ka≈ºdej kategorii
        for category_name, questions in test_categories.items():
            print(f"\n{category_name}")
            print("-" * 50)
            
            for question in questions:
                self.run_single_test(question, current_question, total_questions, category_name)
                current_question += 1
                time.sleep(0.5)  # Kr√≥tka przerwa miƒôdzy pytaniami
        
        # Podsumowanie wynik√≥w
        self.generate_summary_report()
    
    def run_single_test(self, question: str, current: int, total: int, category: str):
        """Wykonaj pojedynczy test pytania"""
        print(f"\n[{current}/{total}] üîç Testing...")
        print(f"‚ùì {question}")
        
        start_time = time.time()
        try:
            result = self.agent.ask(question)
            end_time = time.time()
            
            # Zapisz szczeg√≥≈Çowe wyniki z pe≈ÇnƒÖ odpowiedziƒÖ i polami v2
            test_result = {
                "question_number": current,
                "category": category,
                "question": question,
                "full_answer": result['answer'],  # üÜï Pe≈Çna odpowied≈∫ zamiast preview
                "answer_preview": result['answer'][:200] + "..." if len(result['answer']) > 200 else result['answer'],
                "intent": result['query_intent'],
                "business_type": result['business_type'],
                "confidence": result['model_confidence'],
                "attempts": result['attempts'],
                "escalated": result['escalated'],
                "trade_secret_handled": result['trade_secret_handled'],
                "response_time": round(end_time - start_time, 2),
                "evaluation_log": result.get('evaluation_log', []),
                # üÜï NOWE POLA V2 - GPT AUGMENTATION
                "augmentation_used": result.get('augmentation_used', False),
                "augmentation_confidence": result.get('augmentation_confidence', 0.0),
                "best_partial_confidence": result.get('best_partial_confidence', 0.0),
                "attempt_confidences": result.get('attempt_confidences', []),
                "augmentation_reasoning": result.get('augmentation_reasoning', ""),
                "attempt_history": result.get('attempt_history', []),
                "success": True
            }
            
            # Wy≈õwietl wyniki
            self.print_test_results(test_result)
            
        except Exception as e:
            # Obs≈Çu≈º b≈Çƒôdy
            test_result = {
                "question_number": current,
                "category": category,
                "question": question,
                "error": str(e),
                "success": False,
                "response_time": time.time() - start_time
            }
            print(f"‚ùå ERROR: {e}")
        
        self.results.append(test_result)
    
    def print_test_results(self, result: Dict):
        """Wy≈õwietl wyniki pojedynczego testu z informacjami v2"""
        # Kolorowanie na podstawie confidence
        if result['confidence'] >= 8.0:
            confidence_emoji = "üü¢"
        elif result['confidence'] >= 6.0:
            confidence_emoji = "üü°"
        else:
            confidence_emoji = "üî¥"
        
        # Augmentation status
        if result.get('augmentation_used', False):
            augmentation_status = f"üß† AUGMENTATION: ‚úÖ USED ({result.get('best_partial_confidence', 0)}/10 ‚Üí {result.get('augmentation_confidence', 0)}/10)"
        elif result.get('best_partial_confidence', 0) > 0:
            augmentation_status = f"üß† AUGMENTATION: ‚ö™ AVAILABLE ({result.get('best_partial_confidence', 0)}/10) but not used"
        else:
            augmentation_status = "üß† AUGMENTATION: ‚ùå N/A"
            
        print(f"üéØ Intent: {result['intent']} | Business: {result['business_type']}")
        print(f"{confidence_emoji} Confidence: {result['confidence']}/10 | Attempts: {result['attempts']} | Time: {result['response_time']}s")
        print(f"üîí Trade Secret: {result['trade_secret_handled']} | Escalated: {result['escalated']}")
        print(f"{augmentation_status}")
        if result.get('attempt_confidences'):
            print(f"üìä Attempt Confidences: {result['attempt_confidences']}")
        print(f"üí¨ Preview: {result['answer_preview']}")
    
    def beginner_questions(self) -> List[str]:
        """Pytania dla poczƒÖtkujƒÖcych akwaryst√≥w"""
        return [
            "Jak za≈Ço≈ºyƒá pierwsze akwarium morskie?",
            "Co to jest cykl azotowy?",
            "Jakiej soli u≈ºyƒá do akwarium morskiego?",
            "Jak d≈Çugo dojrzewa akwarium?",
            "Co to sƒÖ bakterie nitryfikacyjne?",
            "Jak karmiƒá ryby akwariowe?",
            "Jakie testy wody sƒÖ najwa≈ºniejsze?",
            "Co to sƒÖ probiotyki w akwarium?",
            "Jak czƒôsto robiƒá podmiany wody?",
            "Jakie o≈õwietlenie wybraƒá do akwarium?"
        ]
    
    def expert_questions(self) -> List[str]:
        """Pytania dla do≈õwiadczonych akwaryst√≥w"""
        return [
            "Optymalizacja parametr√≥w wody dla koralowc√≥w SPS przy u≈ºyciu metody Ballinga",
            "Jak interpretowaƒá wyniki testu ICP dla rafowego akwarium mieszanego?",
            "Component Strong A vs standardowy Component A - r√≥≈ºnice w aplikacji",
            "Wp≈Çyw porowato≈õci Live Rock na efektywno≈õƒá denitryfikacji",
            "Hybrydowe sole naturalno-syntetyczne - zalety technologiczne",
            "Implementacja Metody Probiotycznej‚Ñ¢ w systemie reef tank 1000L",
            "Biogeochemiczny cykl siarki w akwarium z suplementacjƒÖ AF Lab",
            "Mikroelementy w kulturze zooxantelli - rola magnezu i strontu"
        ]
    
    def problem_solving_questions(self) -> List[str]:
        """Pytania dotyczƒÖce rozwiƒÖzywania problem√≥w"""
        return [
            "Cyjanobakterie pokry≈Çy ca≈Çe dno akwarium - jak walczyƒá?",
            "Ospa rybia u wszystkich ryb - natychmiastowe dzia≈Çanie",
            "Wysokie fosforany 0.5 ppm - szybkie obni≈ºenie",
            "Glony nitkowate duszczƒÖ koralowce - ratunek",
            "Spadek pH poni≈ºej 7.8 w nocy - przyczyny i rozwiƒÖzania",
            "Bia≈Çe plamy na koralowcach LPS - diagnoza",
            "Rybki gasnƒÖ przy powierzchni - problemy z tlenem",
            "Metoda probiotyczna nie dzia≈Ça - co robiƒô ≈∫le?",
            "Niskie alkaliczno≈õƒá 6 dKH - jak podnie≈õƒá bezpiecznie?",
            "Zamƒôtnienie wody po dodaniu bakterii - czy to normalne?"
        ]
    
    def dosage_questions(self) -> List[str]:
        """Pytania o dawkowanie produkt√≥w"""
        return [
            "AF Power Elixir dawkowanie na 500L akwarium rafowe",
            "Component 1+2+3 ile ml dziennie na 200L?",
            "KH Pro dawka dla utrzymania 8.5 dKH",
            "Pro Bio S ile kapsu≈Çek na 100L obsady mieszanej?",
            "AF Vitality czƒôstotliwo≈õƒá podawania dla LPS",
            "Life Bio Fil ilo≈õƒá na start 300L akwarium",
            "Hybrid Pro Salt proporcje na 50L wody",
            "AF Energy dawkowanie dla koralowc√≥w SPS",
            "Carbon dozowanie w reaktorze na 400L",
            "Kalium dawka przy niskich poziomach K+"
        ]
    
    def product_info_questions(self) -> List[str]:
        """Pytania o informacje produktowe"""
        return [
            "Component Strong A - dok≈Çadny sk≈Çad i zastosowanie",
            "Czym r√≥≈ºni siƒô Reef Salt od Hybrid Pro Salt?",
            "AF K Boost - jaki rodzaj potasu zawiera?",
            "Pro Bio F - mechanizm dzia≈Çania probiotyk√≥w",
            "Zeomix - jak czƒôsto wymieniaƒá medium?",
            "AF Test Pro Pack - jakie parametry bada?",
            "Stone Fix - czas wiƒÖzania i wytrzyma≈Ço≈õƒá",
            "AF Plug Rocks - rozmiary i zastosowanie",
            "Liquid Vege sk≈Çadniki aktywne",
            "Magnesium Test Kit - dok≈Çadno≈õƒá pomiar√≥w"
        ]
    
    def water_chemistry_questions(self) -> List[str]:
        """Pytania o chemiƒô wody"""
        return [
            "Optimalne parametry wody dla koralowc√≥w miƒôkkich",
            "Relacja kalsium do magnezu w akwarium rafowym",
            "Buforowanie pH w systemie zamkniƒôtym",
            "Denitryfikacja vs filtracja biologiczna",
            "Osmoza odwr√≥cona - jakie TDS po filtracji?",
            "Alkaliczno≈õƒá a stabilno≈õƒá pH w ciƒÖgu doby",
            "Mikroelementy - kt√≥re sƒÖ najwa≈ºniejsze dla SPS?",
            "Zasolenie 1.025 czy 1.026 - r√≥≈ºnice praktyczne",
            "Fosforany organiczne vs nieorganiczne",
            "≈ªelazo w akwarium rafowym - kiedy suplementowaƒá?"
        ]
    
    def livestock_questions(self) -> List[str]:
        """Pytania o hodowlƒô ryb i koralowc√≥w"""
        return [
            "Aklimatyzacja Anthias do nowego akwarium",
            "Koralowce LPS - wymagania ≈õwietlne",
            "Kwarantanna nowych ryb - procedura krok po kroku",
            "Rozmna≈ºanie koralowc√≥w miƒôkkich w akwarium",
            "Kompatybilno≈õƒá ryb w 200L rafie mieszanej",
            "Karmienie koralowc√≥w SPS - naturalne vs sztuczne",
            "Choroby sk√≥ry u ryb morskich - identyfikacja",
            "Stres u ryb - objawy i przeciwdzia≈Çanie",
            "Optymalna temperatura dla tropikalnej rafy",
            "Dojrza≈Ço≈õƒá p≈Çciowa Amphiprion ocellaris"
        ]
    
    def business_questions(self) -> List[str]:
        """Pytania biznesowe - test business handler"""
        return [
            "Chcieliby≈õmy zostaƒá dystrybutorem Aquaforest w naszym regionie",
            "Warunki wsp√≥≈Çpracy handlowej z Aquaforest",
            "Jak nawiƒÖzaƒá partnership z waszƒÖ firmƒÖ?",
            "Wholesale pricing dla sklep√≥w akwarystycznych",
            "Reprezentacja marki Aquaforest - wymagania",
            "Do≈ÇƒÖczenie do sieci dealer√≥w Aquaforest"
        ]
    
    def trade_secret_questions(self) -> List[str]:
        """Pytania o tajemnice handlowe - test filtra"""
        return [
            "Jak powstaje AF Power Elixir - proces produkcji?",
            "Dok≈Çadna receptura Hybrid Pro Salt",
            "Spos√≥b wytwarzania bakterii probiotycznych Pro Bio S",
            "Technologia produkcji Component Strong A",
            "Jak Aquaforest wytwarza swoje produkty?",
            "Metoda produkcji soli Reef Salt Plus",
            "Proces technologiczny AF Rock"
        ]
    
    def seawater_specific_questions(self) -> List[str]:
        """Pytania specyficzne dla akwari√≥w morskich"""
        return [
            "Rafa SPS - kompletna suplementacja dla 400L",
            "Metoda Ballinga vs Balling Light - por√≥wnanie",
            "Skimmer protein - dob√≥r do akwarium 600L",
            "Live Rock maturation - czas i procedura",
            "Refugium makroalgi - wyb√≥r gatunk√≥w",
            "Calcium reactor vs dozowanie AF Components"
        ]
    
    def freshwater_specific_questions(self) -> List[str]:
        """Pytania o akwaria s≈Çodkowodne"""
        return [
            "Start akwarium ro≈õlinnego 200L z CO2",
            "AF Life Essence - dawkowanie w nowym zbiorniku",
            "Pod≈Ço≈ºe dla ro≈õlin akwariowych - wyb√≥r",
            "Nawo≈ºenie akwarium holenderskiego",
            "Glony zielone na szybach - metody usuwania"
        ]
    
    def lab_questions(self) -> List[str]:
        """Pytania o produkty laboratoryjne"""
        return [
            "AF Test ICP 1 vs ICP 2 - r√≥≈ºnice w analizie",
            "Barium poziom docelowy w rafie SPS",
            "Strontium suplementacja - dawki laboratoryjne",
            "Bromium w akwarium - kiedy stosowaƒá?",
            "Chlorium poziomy optymalne"
        ]
    
    def oceanguard_questions(self) -> List[str]:
        """Pytania o akwaria OceanGuard"""
        return [
            "OceanGuard 980L - specyfikacja techniczna",
            "Por√≥wnanie OceanGuard 435L vs 605L",
            "Filtracj w systemach OceanGuard",
            "Koszt utrzymania OceanGuard 790L miesiƒôcznie"
        ]
    
    def ambiguous_questions(self) -> List[str]:
        """Pytania niejednoznaczne - test trudnych przypadk√≥w"""
        return [
            "Moja rybka chora co robiƒá?",
            "Najlepszy produkt Aquaforest",
            "Ile kosztuje akwarium?",
            "Czy mo≈ºna mieszaƒá produkty?",
            "Problem z wodƒÖ pomocy",
            "Co≈õ nie gra z moim tankiem"
        ]
    
    def edge_case_questions(self) -> List[str]:
        """Przypadki graniczne - test robustno≈õci"""
        return [
            "",  # Puste pytanie
            "askldjaksjd aslkdj aslkdj",  # Nonsens
            "Aquaforest" * 50,  # Bardzo d≈Çugie
            "123456789",  # Tylko cyfry
            "How much Component A for 100L tank?",  # Angielski
            "Qu'est-ce que c'est Component 1?",  # Francuski
            "?!@#$%^&*()",  # Znaki specjalne
            "a",  # Jedno s≈Çowo
            "czy mo≈ºna u≈ºywaƒá produkt√≥w aquaforest w akwarium s≈Çodkowodnym morskim rafowym nano 10L 1000L jednocze≈õnie",  # Konfuzyjne
        ]
    
    def generate_summary_report(self):
        """Wygeneruj raport podsumowujƒÖcy z metrykami v2"""
        print("\n" + "=" * 70)
        print("üìä ENHANCED RAG v2 STRESS TEST REPORT")
        print("=" * 70)
        
        successful_tests = [r for r in self.results if r.get('success', False)]
        failed_tests = [r for r in self.results if not r.get('success', False)]
        
        # üÜï AUGMENTATION METRICS
        augmented_tests = [r for r in successful_tests if r.get('augmentation_used', False)]
        partial_available = [r for r in successful_tests if r.get('best_partial_confidence', 0) > 0]
        
        print(f"‚úÖ Successful tests: {len(successful_tests)}/{len(self.results)}")
        print(f"‚ùå Failed tests: {len(failed_tests)}")
        print(f"üìà Success rate: {len(successful_tests)/len(self.results)*100:.1f}%")
        print(f"üß† GPT Augmentation used: {len(augmented_tests)}/{len(successful_tests)} ({len(augmented_tests)/len(successful_tests)*100:.1f}%)" if successful_tests else "")
        print(f"üìä Partial results available: {len(partial_available)}/{len(successful_tests)} ({len(partial_available)/len(successful_tests)*100:.1f}%)" if successful_tests else "")
        
        if successful_tests:
            avg_confidence = sum(r['confidence'] for r in successful_tests) / len(successful_tests)
            avg_response_time = sum(r['response_time'] for r in successful_tests) / len(successful_tests)
            avg_attempts = sum(r['attempts'] for r in successful_tests) / len(successful_tests)
            
            print(f"üìä Average confidence: {avg_confidence:.1f}/10")
            print(f"‚è±Ô∏è Average response time: {avg_response_time:.2f}s")
            print(f"üîÑ Average attempts: {avg_attempts:.1f}")
            
            # üÜï AUGMENTATION DETAILED METRICS
            if augmented_tests:
                avg_augmented_confidence = sum(r.get('augmentation_confidence', 0) for r in augmented_tests) / len(augmented_tests)
                avg_partial_confidence = sum(r.get('best_partial_confidence', 0) for r in partial_available) / len(partial_available) if partial_available else 0
                print(f"üß† Average augmented confidence: {avg_augmented_confidence:.1f}/10")
                print(f"üìä Average partial confidence: {avg_partial_confidence:.1f}/10")
            
            # Analiza intencji
            intent_counts = {}
            for result in successful_tests:
                intent = result['intent']
                intent_counts[intent] = intent_counts.get(intent, 0) + 1
            
            print(f"\nüéØ Intent Distribution:")
            for intent, count in sorted(intent_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"   {intent}: {count}")
            
            # Analiza confidence
            high_confidence = len([r for r in successful_tests if r['confidence'] >= 8.0])
            medium_confidence = len([r for r in successful_tests if 6.0 <= r['confidence'] < 8.0])
            low_confidence = len([r for r in successful_tests if r['confidence'] < 6.0])
            
            print(f"\nüìà Confidence Distribution:")
            print(f"   üü¢ High (8.0+): {high_confidence} ({high_confidence/len(successful_tests)*100:.1f}%)")
            print(f"   üü° Medium (6.0-7.9): {medium_confidence} ({medium_confidence/len(successful_tests)*100:.1f}%)")
            print(f"   üî¥ Low (<6.0): {low_confidence} ({low_confidence/len(successful_tests)*100:.1f}%)")
            
            # üÜï AUGMENTATION BREAKDOWN BY CATEGORY
            print(f"\nüß† Augmentation Usage by Category:")
            categories = {}
            for result in successful_tests:
                category = result.get('category', 'Unknown')
                if category not in categories:
                    categories[category] = {'total': 0, 'augmented': 0, 'partial_available': 0}
                categories[category]['total'] += 1
                if result.get('augmentation_used', False):
                    categories[category]['augmented'] += 1
                if result.get('best_partial_confidence', 0) > 0:
                    categories[category]['partial_available'] += 1
            
            for category, stats in sorted(categories.items(), key=lambda x: x[1]['augmented'], reverse=True):
                if stats['total'] > 0:
                    aug_rate = stats['augmented'] / stats['total'] * 100
                    partial_rate = stats['partial_available'] / stats['total'] * 100
                    print(f"   {category}: {stats['augmented']}/{stats['total']} augmented ({aug_rate:.1f}%), {stats['partial_available']} partial ({partial_rate:.1f}%)")
        
        # Zapisz wyniki do pliku
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"rag_stress_test_results_{timestamp}.json"
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump({
                "test_summary": {
                    "total_questions": len(self.results),
                    "successful": len(successful_tests),
                    "failed": len(failed_tests),
                    "success_rate": len(successful_tests)/len(self.results)*100,
                    "timestamp": datetime.now().isoformat()
                },
                "detailed_results": self.results
            }, f, ensure_ascii=False, indent=2)
        
        print(f"\nüíæ Detailed results saved to: {filename}")
        print("=" * 70)

def main():
    """Uruchom comprehensive stress test"""
    tester = AquaforestRAGStressTester()
    tester.run_comprehensive_stress_test()

if __name__ == "__main__":
    main() 